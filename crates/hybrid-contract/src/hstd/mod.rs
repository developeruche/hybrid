//! # Hybrid Standard Storage Library (hstd)
//!
//! This module provides Solidity-like storage abstractions for the Hybrid VM environment.
//! It implements type-safe storage operations with automatic ABI encoding/decoding and
//! supports common Solidity storage patterns like slots and mappings.
//!
//! ## Overview
//!
//! The storage system is built around several key traits that work together to provide
//! a safe and ergonomic interface for persistent storage:
//!
//! - **`StorageLayout`**: Defines how storage types are allocated in the storage layout
//! - **`StorageStorable`**: Provides low-level storage read/write operations with ABI encoding
//! - **`DirectStorage`**: High-level interface for direct storage access (like `Slot`)
//! - **`IndirectStorage`**: High-level interface for indirect storage access (like mappings)
//!
//! ## Storage Types
//!
//! ### `Slot<T>`
//! Represents a single storage slot that can hold any ABI-encodable value.
//! ```rust,no_run
//! let counter: Slot<U256> = Slot::default();
//! counter.write(U256::from(42));
//! let value = counter.read();
//! ```
//!
//! ### `Mapping<K, V>`
//! Provides Solidity-like mapping functionality with type-safe key-value storage.
//! ```rust,no_run
//! let balances: Mapping<Address, U256> = Mapping::default();
//! balances[user_address].write(U256::from(1000));
//! let balance = balances[user_address].read();
//! ```
//!
//! ## Storage Layout Requirements
//!
//! All storage types must implement specific traits based on their usage:
//!
//! 1. **`StorageLayout`**: Required for all storage types to enable allocation by storage macros
//! 2. **Direct access types** (like `Slot`): Must implement `StorageStorable` and `DirectStorage`
//! 3. **Indirect access types** (like mapping guards): Must implement `IndirectStorage`
//! 4. **Container types** (like `Mapping`): May only implement `StorageLayout` and provide access via guards
//!
//! ## ABI Encoding
//!
//! The storage system automatically handles ABI encoding and decoding of values, ensuring
//! compatibility with Ethereum's storage format and enabling seamless integration with
//! external tools and interfaces.
//!
//! ## Usage with Storage Macros
//!
//! This module is designed to work with storage allocation macros that automatically
//! assign storage slots to contract state variables:
//!
//! ```rust,no_run
//! // This would typically be generated by a macro
//! struct ContractStorage {
//!     counter: Slot<U256>,
//!     balances: Mapping<Address, U256>,
//! }
//! ```

use core::default::Default;
use core::marker::PhantomData;

use crate::*;

use alloy_sol_types::{SolType, SolValue};

extern crate alloc;
use alloc::vec::Vec;

mod mapping;
pub use mapping::Mapping;

mod slot;
pub use slot::Slot;

/// Trait for storage types that require allocation in the contract's storage layout.
///
/// This trait enables storage types to be automatically allocated by storage macros.
/// Each storage type receives a unique 256-bit storage key derived from its position
/// in the contract's storage layout.
///
/// # Arguments
/// The four `u64` parameters represent the four 64-bit limbs of a U256 storage key:
/// * `limb0` - Least significant 64 bits
/// * `limb1` - Second 64 bits
/// * `limb2` - Third 64 bits
/// * `limb3` - Most significant 64 bits
///
/// # Examples
/// ```rust,no_run
/// // Typically implemented by storage types:
/// impl StorageLayout for Slot<U256> {
///     fn allocate(limb0: u64, limb1: u64, limb2: u64, limb3: u64) -> Self {
///         Self {
///             id: U256::from_limbs([limb0, limb1, limb2, limb3]),
///             _phantom: PhantomData,
///         }
///     }
/// }
/// ```
// TODO: enhance `storage` macro to handle complex types (like tuples or custom structs)
pub trait StorageLayout {
    /// Allocates a storage type with the given storage key.
    ///
    /// # Arguments
    /// * `limb0` - Least significant 64 bits of the storage key
    /// * `limb1` - Second 64 bits of the storage key
    /// * `limb2` - Third 64 bits of the storage key
    /// * `limb3` - Most significant 64 bits of the storage key
    ///
    /// # Returns
    /// A new instance of the storage type configured with the provided storage key
    fn allocate(limb0: u64, limb1: u64, limb2: u64, limb3: u64) -> Self;
}

/// Low-level trait for storage operations with ABI encoding/decoding.
///
/// This trait provides the fundamental storage operations used by higher-level
/// storage interfaces. It handles the automatic ABI encoding and decoding of
/// values when they are written to or read from storage.
///
/// # Type Parameters
/// * `Value` - The Rust type that this storage can hold, must be ABI-encodable
///
/// # Safety
/// Implementations of this trait directly interact with the EVM storage system
/// via SLOAD and SSTORE operations. The encoding/decoding must be consistent
/// to avoid data corruption.
pub trait StorageStorable {
    /// The type of value this storage can hold
    type Value: SolValue
        + core::convert::From<<<Self::Value as SolValue>::SolType as SolType>::RustType>;

    /// Reads a value from storage at the specified key.
    ///
    /// # Arguments
    /// * `key` - The storage key to read from
    ///
    /// # Returns
    /// The decoded value from storage
    fn __read(key: U256) -> Self::Value;

    /// Writes a value to storage at the specified key.
    ///
    /// # Arguments
    /// * `key` - The storage key to write to
    /// * `value` - The value to encode and store
    fn __write(key: U256, value: Self::Value);
}

/// High-level interface for storage types with direct access patterns.
///
/// This trait provides a user-friendly interface for storage types that can be
/// directly read from and written to, such as `Slot<T>`. It abstracts away the
/// underlying storage key management and ABI encoding concerns.
///
/// # Type Parameters
/// * `V` - The value type that can be stored and retrieved
///
/// # Examples
/// ```rust,no_run
/// let counter: Slot<U256> = Slot::default();
/// counter.write(U256::from(42));  // Direct write
/// let value = counter.read();     // Direct read
/// ```
pub trait DirectStorage<V>
where
    Self: StorageStorable<Value = V>,
{
    /// Reads the current value from storage.
    ///
    /// # Returns
    /// The current value stored in this storage location
    fn read(&self) -> V;

    /// Writes a new value to storage.
    ///
    /// # Arguments
    /// * `value` - The new value to store
    fn write(&mut self, value: V);
}

/// High-level interface for storage types with indirect access patterns.
///
/// This trait provides an interface for storage types that require a guard or
/// intermediate object to perform reads and writes, such as mapping guards.
/// This pattern is used when the storage location is computed dynamically.
///
/// # Type Parameters
/// * `V` - The storage type that can be accessed indirectly
///
/// # Examples
/// ```rust,no_run
/// let balances: Mapping<Address, U256> = Mapping::default();
/// let user_balance = &balances[user_address];  // Returns a guard
/// user_balance.write(U256::from(1000));        // Indirect write via guard
/// let balance = user_balance.read();           // Indirect read via guard
/// ```
pub trait IndirectStorage<V>
where
    V: StorageStorable,
    V::Value:
        SolValue + core::convert::From<<<V::Value as SolValue>::SolType as SolType>::RustType>,
{
    /// Reads the value from the storage location managed by this guard.
    ///
    /// # Returns
    /// The current value at the storage location
    fn read(&self) -> V::Value;

    /// Writes a value to the storage location managed by this guard.
    ///
    /// # Arguments
    /// * `value` - The new value to store
    fn write(&mut self, value: V::Value);
}
