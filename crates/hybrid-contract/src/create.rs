//! # Contract Deployment Interface
//!
//! This module provides functionality for deploying smart contracts in the Hybrid VM environment.
//! It implements type-safe contract deployment with constructor argument handling and automatic
//! interface generation for the deployed contracts.
//!
//! ## Features
//! - Type-safe contract deployment with constructor arguments
//! - Automatic ABI encoding of constructor parameters
//! - R55 initcode format support (0xFF prefix + codesize + bytecode + args)
//! - Integration with the contract interface system
//! - Compile-time context checking for deployment operations
//!
//! ## R55 Initcode Format
//! The deployment uses a custom initcode format:
//! ```text
//! [0xFF][codesize (4 bytes)][runtime_bytecode][constructor_args]
//! ```
//!
//! ## Usage
//! ```rust,no_run
//! use hybrid_contract::create::*;
//!
//! // Deploy a contract with constructor arguments
//! let contract = MyContract::deploy((arg1, arg2))
//!     .with_ctx(&mut ctx);
//! ```

extern crate alloc;
use alloy_core::primitives::{Address, Bytes, U32};
use alloy_sol_types::{SolType, SolValue};
use core::{arch::asm, marker::PhantomData, u64};
use ext_alloc::vec::Vec;
use hybrid_syscalls::Syscall;

use crate::{FromBuilder, InitInterface, MethodCtx, ReadWrite};

/// Trait for contracts that can be deployed to the blockchain.
///
/// This trait defines the interface for deployable contracts, providing access to
/// their runtime bytecode and deployment functionality with constructor arguments.
pub trait Deployable {
    /// The interface type that will be returned after deployment
    type Interface: InitInterface;

    /// Returns the contract's runtime bytecode.
    ///
    /// This should return the compiled bytecode that will be stored on-chain
    /// after successful deployment. This is typically generated by the compiler
    /// and embedded as a static byte array.
    fn __runtime() -> &'static [u8];

    /// Convenience method to get the runtime bytecode as a `Bytes` object.
    ///
    /// # Returns
    /// The contract's runtime bytecode wrapped in a `Bytes` container
    fn bytecode() -> Bytes {
        Bytes::from(Self::__runtime())
    }

    /// Creates a deployment builder with the specified constructor arguments.
    ///
    /// This method initiates the deployment process by creating a builder that
    /// captures the constructor arguments and will handle the actual deployment
    /// when `with_ctx()` is called.
    ///
    /// # Arguments
    /// * `args` - The constructor arguments, must implement `SolValue` for ABI encoding
    ///
    /// # Returns
    /// A `DeploymentBuilder` that can be used to complete the deployment
    fn deploy<Args>(args: Args) -> DeploymentBuilder<Self, Args>
    where
        Self: Sized,
        Args: SolValue + core::convert::From<<<Args as SolValue>::SolType as SolType>::RustType>,
    {
        DeploymentBuilder {
            args,
            _phantom: PhantomData,
        }
    }
}

/// Builder for deploying contracts with constructor arguments.
///
/// This structure captures the constructor arguments and provides methods to
/// complete the deployment process. It ensures type safety by requiring that
/// constructor arguments implement the necessary traits for ABI encoding.
///
/// # Type Parameters
/// * `D` - The deployable contract type
/// * `Args` - The type of the constructor arguments
pub struct DeploymentBuilder<D: Deployable + ?Sized, Args>
where
    Args: SolValue + core::convert::From<<<Args as SolValue>::SolType as SolType>::RustType>,
{
    /// The constructor arguments for the contract
    args: Args,
    /// Phantom data to maintain type information about the deployable contract
    _phantom: PhantomData<D>,
}

impl<D: Deployable, Args> DeploymentBuilder<D, Args>
where
    Args: SolValue + core::convert::From<<<Args as SolValue>::SolType as SolType>::RustType>,
{
    /// Completes the contract deployment with the specified execution context.
    ///
    /// This method performs the actual deployment by:
    /// 1. ABI-encoding the constructor arguments
    /// 2. Creating R55 initcode (0xFF + codesize + bytecode + args)
    /// 3. Executing the CREATE syscall
    /// 4. Retrieving the deployed contract address
    /// 5. Creating and returning a typed interface to the deployed contract
    ///
    /// # Arguments
    /// * `ctx` - The method context, must allow mutable operations (ReadWrite)
    ///
    /// # Returns
    /// A typed interface to the deployed contract
    ///
    /// # Type Parameters
    /// * `M` - The method context type, constrained to mutable contexts
    /// * `T` - The target interface type to return
    pub fn with_ctx<M, T>(self, ctx: M) -> T
    where
        M: MethodCtx<Allowed = ReadWrite>, // Constrain to mutable contexts only
        D::Interface: InitInterface,
        T: FromBuilder<Context = M::Allowed>,
        D::Interface: crate::IntoInterface<T>,
    {
        let bytecode = D::__runtime();
        let encoded_args = self.args.abi_encode();

        // Craft R55 initcode: [0xFF][codesize][bytecode][constructor_args]
        let codesize = U32::from(bytecode.len());

        let mut init_code = Vec::new();
        init_code.push(0xff);
        init_code.extend_from_slice(&Bytes::from(codesize.to_be_bytes_vec()));
        init_code.extend_from_slice(&bytecode);
        init_code.extend_from_slice(&encoded_args);

        let offset = init_code.as_ptr() as u64;
        let size = init_code.len() as u64;

        // TODO: think of an ergonomic API to handle deployments with values
        create(0, offset, size);

        // Get deployment address
        let mut ret_data = Vec::with_capacity(20);
        ret_data.resize(20 as usize, 0);
        return_create_address(ret_data.as_ptr() as u64);

        let address = Address::from_slice(&ret_data);

        // Create the interface builder
        let builder = D::Interface::new(address);

        // Convert to the actual interface with context
        builder.with_ctx(ctx)
    }
}

/// Low-level contract creation via RISC-V system call.
///
/// This function performs the actual EVM CREATE operation through a system call
/// to the Hybrid VM. It deploys a contract using the provided initcode.
///
/// # Arguments
/// * `value` - Amount of wei to send to the contract during creation
/// * `data_offset` - Memory offset of the initcode
/// * `data_size` - Size of the initcode in bytes
///
/// # Safety
/// Uses inline assembly and assumes the caller has prepared valid initcode.
fn create(value: u64, data_offset: u64, data_size: u64) {
    unsafe {
        asm!(
            "ecall",
            in("a0") value, in("a1") data_offset, in("a2") data_size,
            in("t0") u8::from(Syscall::Create)
        );
    }
}

/// Retrieves the address of the most recently created contract.
///
/// This function copies the address of the contract that was just deployed
/// via the CREATE syscall into the specified memory location.
///
/// # Arguments
/// * `data_offset` - Memory offset where the 20-byte address should be written
///
/// # Safety
/// The caller must ensure that the destination memory location can safely
/// accommodate 20 bytes and that a contract was actually just created.
fn return_create_address(data_offset: u64) {
    unsafe {
        asm!(
            "ecall", in("a0") data_offset, in("t0") u8::from(Syscall::ReturnCreateAddress));
    }
}
