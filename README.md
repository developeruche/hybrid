# Hybrid Framework

A comprehensive blockchain development framework that enables writing smart contracts in Rust and deploying them on EVM-compatible blockchains.

## Overview

The Hybrid Framework bridges the Rust and Ethereum ecosystems by allowing developers to write smart contracts in Rust that compile to RISC-V bytecode and execute seamlessly on any EVM-compatible blockchain. The framework provides a complete toolchain from development to deployment, including a custom Ethereum node implementation.

## Key Features

- **Rust Smart Contracts**: Write contracts in Rust with full type safety and memory safety
- **EVM Compatibility**: Deploy and interact with contracts on any EVM-compatible blockchain
- **Complete Toolchain**: Full development lifecycle support from creation to deployment
- **Standard Integration**: Works with existing Ethereum tools (Hardhat, Foundry, web3 libraries)
- **Custom Node**: Standalone Ethereum node with native RISC-V contract execution
- **Performance Optimized**: Efficient RISC-V emulation with future JIT compilation support

## Quick Start

### Installation

```bash
# Install the Hybrid CLI tool
cargo install --path bins/cargo-hybrid
```

### Create Your First Contract

```bash
# Create a new contract project
cargo hybrid new my_contract
cd my_contract

# Build the contract
cargo hybrid build

# Start a development node (optional)
cargo hybrid node
```

### Example Contract

```rust
#![no_std]
#![no_main]

use alloy_core::primitives::{Address, U256};
use hybrid_contract::hstd::*;
use hybrid_derive::{contract, storage, Event, Error};

#[derive(Event)]
pub struct Transfer {
    #[indexed]
    pub from: Address,
    #[indexed] 
    pub to: Address,
    pub amount: U256,
}

#[derive(Error)]
pub enum TokenError {
    InsufficientBalance(U256),
    ZeroAmount,
}

#[storage]
pub struct Token {
    balances: Mapping<Address, Slot<U256>>,
    total_supply: Slot<U256>,
}

#[contract]
impl Token {
    pub fn new(initial_supply: U256) -> Self {
        let mut token = Token::default();
        let deployer = msg_sender();
        
        token.balances[deployer].write(initial_supply);
        token.total_supply.write(initial_supply);
        
        log::emit(Transfer::new(Address::ZERO, deployer, initial_supply));
        token
    }
    
    pub fn transfer(&mut self, to: Address, amount: U256) -> Result<bool, TokenError> {
        let from = msg_sender();
        let from_balance = self.balances[from].read();
        
        if from_balance < amount {
            return Err(TokenError::InsufficientBalance(from_balance));
        }
        if amount == U256::ZERO {
            return Err(TokenError::ZeroAmount);
        }
        
        self.balances[from].write(from_balance - amount);
        let to_balance = self.balances[to].read();
        self.balances[to].write(to_balance + amount);
        
        log::emit(Transfer::new(from, to, amount));
        Ok(true)
    }
    
    pub fn balance_of(&self, owner: Address) -> U256 {
        self.balances[owner].read()
    }
}
```

## CLI Commands

### Project Management
```bash
cargo hybrid new <name>        # Create new contract project
cargo hybrid build             # Compile contract to RISC-V bytecode
cargo hybrid check             # Check contract syntax and types
```

### Deployment & Testing
```bash
cargo hybrid deploy [OPTIONS]  # Deploy contract to blockchain
cargo hybrid node              # Start development node
```

### Deploy Options
```bash
# Deploy to local development node
cargo hybrid deploy

# Deploy to specific network
cargo hybrid deploy --rpc-url https://mainnet.infura.io/v3/YOUR-KEY --private-key YOUR-PRIVATE-KEY

# Deploy with constructor arguments
cargo hybrid deploy --constructor-args "1000000000000000000000"
```

## Architecture

The framework consists of several key components:

- **hybrid-derive**: Procedural macros for contract development (`#[contract]`, `#[storage]`, etc.)
- **hybrid-compile**: Rust-to-RISC-V compilation pipeline
- **hybrid-vm**: Virtual machine for executing RISC-V contracts in EVM context
- **hybrid-ethereum**: Custom Ethereum node implementation using Reth
- **rvemu**: RISC-V emulator implementation
- **cargo-hybrid**: Command-line interface for development workflow

## Contract Structure

Hybrid contracts require specific project structure:

```
my_contract/
├── Cargo.toml          # Must include required features and dependencies
├── src/
│   └── lib.rs          # Contract implementation
└── out/                # Generated bytecode (after build)
    └── my_contract.bin
```

### Required Cargo.toml Configuration

```toml
[package]
name = "my_contract"
version = "0.1.0"
edition = "2021"

[features]
default = []
deploy = []
interface-only = []

[dependencies]
hybrid-derive = { path = "path/to/hybrid-derive" }
hybrid-contract = { path = "path/to/hybrid-contract" }
alloy-core = { version = "0.8.20", default-features = false }

[[bin]]
name = "runtime"
path = "src/lib.rs"

[[bin]]
name = "deploy"
path = "src/lib.rs"
required-features = ["deploy"]

[profile.release]
lto = true
opt-level = "z"
```

## Development Workflow

1. **Create Project**: Use `cargo hybrid new` to scaffold a new contract
2. **Implement Logic**: Write contract in `src/lib.rs` using Hybrid macros
3. **Local Testing**: Use `cargo test` for unit tests
4. **Build**: Compile with `cargo hybrid build`
5. **Deploy**: Deploy with `cargo hybrid deploy`
6. **Interact**: Use standard Ethereum tools for interaction

## Integration with Ethereum Tooling

Hybrid contracts are fully compatible with the Ethereum ecosystem:

### Web3 Libraries
```javascript
// Standard web3.js/ethers.js interaction
const contract = new ethers.Contract(address, abi, provider);
const result = await contract.transfer(recipient, amount);
```

### Hardhat Integration
```javascript
// hardhat.config.js
module.exports = {
  networks: {
    hybrid: {
      url: "http://127.0.0.1:8545", // Hybrid node URL
      chainId: 1337
    }
  }
};
```

### Foundry Support
```bash
# Standard forge commands work with deployed contracts
forge test --rpc-url http://127.0.0.1:8545
```

## Performance

- **Compilation**: ~10-30 seconds for typical contracts
- **Execution**: ~10-100x slower than native EVM (due to RISC-V emulation)
- **Gas Usage**: Higher gas consumption due to emulation overhead
- **Binary Size**: ~10-50KB for typical contracts

## Examples

The `contracts/` directory contains example implementations:

- **ERC20**: Standard fungible token implementation
- **Storage**: Basic storage operations and patterns

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Submit a pull request

## License

MIT License - see LICENSE file for details

## Documentation

For detailed architecture information, see [ARCHITECTURE.md](crates/ARCHITECTURE.md).

## Support

- **GitHub Issues**: Bug reports and feature requests
- **Documentation**: Architecture and API documentation
- **Examples**: Sample contracts in `contracts/` directory

---

**Note**: This is experimental technology. Use with caution in production environments.